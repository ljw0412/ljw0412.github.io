<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/2025/01/25/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2025/01/25/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap的实现原理、扩容机制在jdk1.7以前和jdk1.8以后有着很大的区别，由于我的电脑上的版本是jdk21，所以以下近针对jdk1.8以后。</p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    Node&lt;K,V&gt; next;<br><br>    Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br></code></pre></td></tr></table></figure><p>在jdk1.8中，hashmap是由<strong>数组+链表&#x2F;红黑树</strong>构成的。数组中每个位置存放的都是链表或者红黑树。图解如下：</p><p><img src="/.com//HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5C4243d758576a4191867b557a03044c4f.png" alt="HashMap的底层实现原理"></p><h2 id="一些重要参数"><a href="#一些重要参数" class="headerlink" title="一些重要参数"></a>一些重要参数</h2><p><strong>默认初始化大小</strong>：16，这个是指桶的数量，一般都是2的次幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br></code></pre></td></tr></table></figure><p><strong>负载因子</strong>：0.75</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 0.75">static final float DEFAULT_LOAD_FACTOR = 0.75f;<br></code></pre></td></tr></table></figure><p><strong>桶的树化阈值</strong>：8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p><strong>桶的链表还原阈值</strong>：6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p><strong>最小树形化容量阈值</strong>：64</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure><p><strong>扩容阈值Threshold</strong>：</p><p>初始化Threshold的方法tableSizeFor()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-comment">// 得到比capacity大的最小的2的幂次方数-1的数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>会得到一个大于等于传入的capacity的最小2次幂。</p><p><strong>tips：在初始化的时候，阈值是等于容量的；当放入第一个元素后，重新计算阈值，新的阈值&#x3D;容量X负载因子。</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>当HashMap创建完成之后，并没有初始化table数组，而是在<strong>第一次存放元素的时候才会通过resize方法执行初始化</strong>操作。</p><p>一般不会修改负载因子，这里只说initialCapacity。</p><p>有两种情况：</p><ol><li><p>第一种：无参构造。</p><p><img src="/.com//HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5Cimage-20250125161817433.png" alt="image-20250125161817433"></p><p>不指定capacity大小时，默认初始化大小为16。</p></li><li><p>第二种：指定初始容量的有参构造。</p><p><img src="/.com//HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5Cimage-20250125161801735.png" alt="image-20250125161801735"></p><p>这里有点复杂，简单来说就是找到一个大于等于10的2的次幂进行初始化。</p><p>详细来讲，首先是将capacity赋值为10，计算threshold为16。然后在resize里面oldCap是计算len的，第一次的话必然是0，oldThr的值是直接从threshold赋值的，这里是16。接下来会依次进入下面框起来的两个if语句里，在这里面把oldThr赋值给了newCap，其实就是将我们开始计算的threshold作为了新的capacity，然后根据capacity*loadFactor计算新的threshold。</p><p><img src="/.com//HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5Cimage-20250125165320667.png" alt="image-20250125165320667"></p></li></ol><h2 id="扩容-迁移"><a href="#扩容-迁移" class="headerlink" title="扩容 &amp; 迁移"></a>扩容 &amp; 迁移</h2><ol><li><p>根据新的容量新建一个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br></code></pre></td></tr></table></figure></li><li><p>迁移：</p><p>从数组的第一个元素开始向后遍历，根据元素的类型是链表还是红黑树来分情况处理：</p><ol><li>元素既非链表也非红黑树，直接计算新的位置赋值</li><li>元素为单链表，遍历单链表，通过<strong>hash &amp; oldCap</strong>结果是否0拆分为两个链表，为0时下标仍然为index，结果为1时下标为index + oldCap。</li><li>元素为红黑树，遍历红黑树通过hash &amp; oldCap结果是否0拆分为两条单链表，如果拆分后的链表长度仍满足红黑树要求，则重建红黑树，如不满足，将TreeNode替换为Node，还原成单链表。</li></ol></li></ol><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><ol><li><p>计算hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>判断table是否初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>    n = (tab = resize()).length;<br></code></pre></td></tr></table></figure></li><li><p>计算元素位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash])<br></code></pre></td></tr></table></figure></li><li><p>目标位置没有元素存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>    tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>直接将key、value封装成Node对象之后存放在目标位置。</p></li><li><p>目标位置有元素存在：需要找到具体的位置（要么key已经存在，找到那个node；要么key不存在，找到要插入的位置）</p><p>case1：目标位置第一个元素的key值就是当前要push的key值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>    e = p;<br></code></pre></td></tr></table></figure><p>case2：不满足case 1，且目标位置是红黑树结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br></code></pre></td></tr></table></figure><p>从树中逐级查找是否存在节点满足 “&#x3D;&#x3D;“ 或 “equals”，如果存在，则将值替换，如果不存在则在原来的树中新增node。</p><p>case3：不满足case 1，且目标位置是链表结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>            treeifyBin(tab, hash);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">break</span>;<br>        p = e;<br>&#125;<br></code></pre></td></tr></table></figure><p>则从链表头向后查找满足 “&#x3D;&#x3D;” 或 “equals” 的元素替换其value，如果找不到则新增节点到链表尾端。此时如果表长度到达<strong>桶的树化阈值</strong>，则将链表以hash值大小为基准构建红黑树。</p><p><strong>tips：</strong></p><p>如果table的长度还没有达到<strong>最小树形化容量阈值</strong>，则优先考虑扩容。</p></li><li><p>一些善后工作</p><p>新增操作会在返回前递增modCount和size并检查扩容阈值threshold，如果size超过了threshold，需要扩容，调resize方法，将容量翻倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">++modCount;<br><span class="hljs-keyword">if</span> (++size &gt; threshold)  resize();<br></code></pre></td></tr></table></figure></li></ol><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><p>get操作不像push和remove会涉及到元素增多或者减少，所以没有什么特别的。先计算hash值查找桶，遍历桶对比是否有此key，有的话返回对应的value，没有则返回null。</p><h2 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h2><p>计算hash值，查找元素，进行删除</p><p><strong>tips</strong>：如果是在红黑树中进行删除的，则需要检查是否要转链表。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
